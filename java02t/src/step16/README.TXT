[주제: 네트워크 프로그래밍과 멀티 스레딩]
ex01 - Echo Client/Server 만들기

ex02 - 입/출력 스트림의 레퍼런스 관리

ex03 - Echo 서버 변경
  => 반복해서 클라이언트의 요청을 처리하도록 변경한다.
  => 클라이언트에서는 사용자로부터 입력 받아서 서버에 보내도록 변경한다.
  => backlog: 대기열 크기
     대기열 크기만큼 클라이언트 연결을 보유할 수 있다.
     대기열을 초과하는 클라이언트 연결은 허용하지 않는다. 
     클라이언트 입장에서는 내부의 기본 대기 시간(timeout)동안 연결을 시도하다가 
     계속 연결이 안되면 예외를 발생시킨다.
  => 반복문을 통해 순차적으로 클라이언트 요청을 처리한다.
     => 한 클라이언트 요청 처리가 끝날 때까지 다른 클라이언트들은 기다려야 한다.
     => 동시에 클라이언트 요청을 처리하려면? 멀티 스레딩 기법을 도입하라!
     
ex04 - 스레드를 이용하여 클라이언트 요청을 동시에 처리하기   
  => Thread를 상속 받은 MyThread 만들기
  
ex05 - 스레드를 이용하여 클라이언트 요청을 동시에 처리하기
  => Server
     - Runnable 인터페이스를 이용하여 클라이언트 요청 처리하기
     - 클라이언트가 bye를 입력하기 전까지 계속 연결된채로 요청을 처리한다.
  => Client 
     - bye를 입력하기 전까지는 계속 실행하도록 변경한다.

* 개념 정리
1) Connectionful(Stateful)
  => 예) FTP, Telnet
  => 특징
    . 한 번 연결한 후, 요청/응답을 반복한다.
    . 클라이언트의 상태 정보를 관리할 수 있다.
    . 클라이언트랑 계속 연결된 채로 있기 때문에 메모리가 낭비된다.
    . 소수의 클라이언트에게 서비스 할 때 좋다.
2) Connectionless(Stateless)
  => 예) HTTP, echo
  => 특징
    . 요청할 때 마다 매번 서버에 연결한다. => 매번 요청 때 마다 연결 시간이 소요된다.
    . 클라이언트 상태를 관리하기 어렵다.
    . 많은 클라이언트에게 서비할 때 좋다.
       
ex06 - Quiz
  => Client
     - 매번 서버에 요청할 때 마다 연결하고, 서버로부터 응답을 받으면 연결을 끊는다.
     - 출력 화면: 
     입력> a=10&b=20&op=+
     결과 = 30
  => Server
     - 클라이언트 요청이 들어오면 스레드를 생성하여 처리를 위임한다.
     - 스레드는 클라이언트가 보낸 문자열을 해석하여 계산을 수행한 후 
       그 결과를 응답한다. 그리고 스레드를 종료한다.
  => 프로토콜(Protocol)
     - Request
       a=값&b=값&op=연산자(LF)
       . 값? 4바이트 정수 값
       . 연산자? +, -, *, /
     - Response
       결과(LF)
       . 결과? 4바이트 정수 값 
              
ex07 - 다중 클라이언트 채팅 구현

ex08 - 파일 전송 구현 
  => 클라이언트 사용법
     > java -cp ./bin step16.ex08.client.FileClient c:/test/a.gif
     전송 완료!
     > 
  
  => 서버 사용법
     > java -cp ./bin step16.ex08.server.FileServer c:/test2
     a.gif 파일 저장 완료!
     
  => 실행 결과 확인
     - c:/test2 폴더에 가서 a.gif 이름을 갖는 파일이 있는지 확인하고, 
       그림판이나 미리보기 등의 프로그램을 사용하여 그림 파일을 출력해 본다.
  
  
  
  
  
  
  
  
  
  
       
       
       